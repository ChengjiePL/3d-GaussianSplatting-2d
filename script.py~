import torch
import torchvision
import torch.nn as nn
import matplotlib.pyplot as plt
from tqdm import tqdm
from PIL import Image

# ===========================
# Configuración inicial
# ===========================
device = "cuda" if torch.cuda.is_available() else "cpu"
print(f"Usando dispositivo: {device}")

# Imagen objetivo
target_image = Image.open("a.png").convert("RGB")
target_image = torchvision.transforms.Resize((256, 256))(target_image)
target_image = torchvision.transforms.ToTensor()(target_image).to(device)

# Parámetros
img_size = (256, 256)
num_gaussians = 2000

# ===========================
# Inicialización aleatoria
# ===========================
positions = torch.rand(num_gaussians, 3, device=device) * 2 - 1    # [x, y, z] en [-1, 1]
positions[:, 2] += 2.0  # Alejarlas un poco del plano
colors = torch.rand(num_gaussians, 3, device=device)               # [r, g, b]
sizes = torch.rand(num_gaussians, device=device) * 0.05 + 0.01     # Tamaño de la gaussiana
positions.requires_grad = True
colors.requires_grad = True
sizes.requires_grad = True

# ===========================
# Proyección en 2D (Renderizado)
# ===========================
def project_gaussians(positions, colors, sizes):
    img = torch.zeros(3, img_size[0], img_size[1], device=device)
    for i in range(num_gaussians):
        x, y, z = positions[i]
        if z > 0:  # Solo renderizamos si está frente a la cámara
            screen_x = int((x / z) * 100 + img_size[0] // 2)
            screen_y = int((y / z) * 100 + img_size[1] // 2)
            
            if 0 <= screen_x < img_size[0] and 0 <= screen_y < img_size[1]:
                # Renderizamos un punto en el plano
                gaussian_color = colors[i].view(3, 1, 1)
                size = max(int(sizes[i] * 100), 1)
                img[:, 
                    max(0, screen_y - size):min(img_size[1], screen_y + size),
                    max(0, screen_x - size):min(img_size[0], screen_x + size)
                ] += gaussian_color
    return torch.clamp(img, 0, 1)

# ===========================
# Optimización (ajuste de posición, color y tamaño)
# ===========================
optimizer = torch.optim.Adam([positions, colors, sizes], lr=0.01)
num_epochs = 500

for epoch in tqdm(range(num_epochs)):
    optimizer.zero_grad()
    img = project_gaussians(positions, colors, sizes)
    loss = nn.functional.mse_loss(img, target_image)
    loss.backward()
    optimizer.step()
    
    if epoch % 50 == 0 or epoch == num_epochs - 1:
        print(f"Epoch {epoch} - Pérdida: {loss.item()}")
        plt.imshow(img.permute(1, 2, 0).cpu().detach().numpy())
        plt.title(f"Iteración {epoch}")
        plt.show()

# Guardar resultado final
torchvision.utils.save_image(img, "resultado_final.png")
